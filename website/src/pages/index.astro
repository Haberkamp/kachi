---
import "../styles.css";
import "../fonts.css";
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />

		<meta name="theme-color" content="#000000" />

		<title>Kachi - Visually display your keystrokes</title>
		<meta
			name="description"
			content="Kachi is a tool that allows you to visually display your keystrokes in real time."
		/>
	</head>
	<body class="bg-black selection:bg-white selection:text-black">
		<div class="relative h-screen w-screen overflow-hidden">
			<video
				id="hero-video"
				src="/video.mp4"
				autoplay
				muted
				loop
				playsinline
				class="-z-10 absolute inset-0 w-full h-full object-cover opacity-0 transition-opacity duration-1000"
			></video>

			<div class="absolute w-full max-w-[calc(100%-theme(spacing.16))] z-10 left-8 md:left-32 bottom-12 md:bottom-24">
				<h1 class="text-white text-6xl font-light leading-[1.1]">Kachi</h1>

				<div class="pt-2" />

				<p class="text-white text-lg leading-[1.3] font-light text-balance">
					Visually display your keystrokes in real time.
				</p>

				<div class="pt-8" />

				<div class="relative inline-block" id="button-wrapper">
					<canvas id="button-canvas" class="absolute inset-0 pointer-events-none"></canvas>
					<button id="download-btn" class="relative z-10 select-none text-white mix-blend-difference bg-transparent px-4 min-h-12 cursor-pointer focus-visible:outline-2 focus-visible:outline-white focus-visible:outline-offset-4 focus-visible:active:bg-black focus-visible:active:text-white focus-visible:active:mix-blend-normal flex flex-row-reverse items-center gap-2">
						<svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M11 5C11 4.44772 11.4477 4 12 4C12.5523 4 13 4.44772 13 5V12.1578L16.2428 8.91501L17.657 10.3292L12.0001 15.9861L6.34326 10.3292L7.75748 8.91501L11 12.1575V5Z" fill="currentColor" />
							<path d="M4 14H6V18H18V14H20V18C20 19.1046 19.1046 20 18 20H6C4.89543 20 4 19.1046 4 18V14Z" fill="currentColor" />
						</svg>
						Download for macOS
					</button>
				</div>
			</div>
		</div>
		<script>
			const video = document.getElementById("hero-video");
			video?.addEventListener("loadeddata", () => {
				video.classList.remove("opacity-0");
				video.classList.add("opacity-100");
			});

			// Ripple button animation
			const canvas = document.getElementById("button-canvas") as HTMLCanvasElement;
			const button = document.getElementById("download-btn") as HTMLButtonElement;
			const ctx = canvas.getContext("2d")!;

			const CELL_SIZE = 10;
			let cols = 0;
			let rows = 0;
			let cells: number[][] = []; // 0 = white, 1 = black
			let targetCells: number[][] = [];
			let animationFrame: number | null = null;
			let isHovered = false;
			let rippleGeneration = 0;

			// Touch-specific state
			let isTouchDevice = false;
			let touchEnterAnimationRunning = false;
			let touchExitAnimationRunning = false;
			let touchFullyBlackTime: number | null = null;
			let touchExitTimeout: number | null = null;
			const TOUCH_MIN_BLACK_DURATION = 300;

			// Keyboard-specific state
			let keyboardPressed = false;
			let keyboardRippleProgress = 0; // 0 = fully white, 1 = fully black
			let keyboardAnimationFrame: number | null = null;
			let keyboardMaxDist = 0;

			function resizeCanvas() {
				const rect = button.getBoundingClientRect();
				canvas.width = rect.width;
				canvas.height = rect.height;
				cols = Math.ceil(rect.width / CELL_SIZE);
				rows = Math.ceil(rect.height / CELL_SIZE);
				
				// Initialize cells to white (0)
				cells = Array.from({ length: rows }, () => Array(cols).fill(0));
				targetCells = Array.from({ length: rows }, () => Array(cols).fill(0));
				draw();
			}

			function draw() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				for (let r = 0; r < rows; r++) {
					for (let c = 0; c < cols; c++) {
						const value = cells[r][c];
						const gray = Math.round(255 * (1 - value));
						ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
						ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
					}
				}
			}

			function animate() {
				let needsUpdate = false;
				const speed = 0.15;

				for (let r = 0; r < rows; r++) {
					for (let c = 0; c < cols; c++) {
						const target = targetCells[r][c];
						if (Math.abs(cells[r][c] - target) > 0.01) {
							cells[r][c] += (target - cells[r][c]) * speed;
							needsUpdate = true;
						} else {
							cells[r][c] = target;
						}
					}
				}

				draw();

				if (needsUpdate) {
					animationFrame = requestAnimationFrame(animate);
				} else {
					animationFrame = null;
					// Check if we just finished the touch enter animation
					if (touchEnterAnimationRunning) {
						checkTouchFullyBlack();
					}
				}
			}

			function startAnimation() {
				if (!animationFrame) {
					animationFrame = requestAnimationFrame(animate);
				}
			}

			function triggerRipple(mouseX: number, mouseY: number) {
				const rect = button.getBoundingClientRect();
				const x = mouseX - rect.left;
				const y = mouseY - rect.top;
				const startCol = Math.floor(x / CELL_SIZE);
				const startRow = Math.floor(y / CELL_SIZE);

				// Calculate max distance for delay scaling
				const maxDist = Math.sqrt(cols * cols + rows * rows);
				const currentGeneration = rippleGeneration;

				for (let r = 0; r < rows; r++) {
					for (let c = 0; c < cols; c++) {
						const dist = Math.sqrt((c - startCol) ** 2 + (r - startRow) ** 2);
						const delay = (dist / maxDist) * 350; // max 600ms delay

						setTimeout(() => {
							// Ignore if this ripple generation is stale
							if (currentGeneration !== rippleGeneration) return;
							if (isHovered) {
								targetCells[r][c] = 1;
								startAnimation();
							}
						}, delay);
					}
				}
			}

			function resetCells() {
				// Instant reset - all cells turn white at once
				for (let r = 0; r < rows; r++) {
					for (let c = 0; c < cols; c++) {
						targetCells[r][c] = 0;
					}
				}
				startAnimation();
			}

			function isTouchFullyBlack(): boolean {
				for (let r = 0; r < rows; r++) {
					for (let c = 0; c < cols; c++) {
						if (cells[r][c] < 0.99) return false;
					}
				}
				return true;
			}

			function checkTouchFullyBlack() {
				if (touchEnterAnimationRunning && isTouchFullyBlack()) {
					touchEnterAnimationRunning = false;
					touchFullyBlackTime = Date.now();
					scheduleTouchExit();
				}
			}

			function scheduleTouchExit() {
				if (touchExitTimeout !== null) {
					clearTimeout(touchExitTimeout);
				}

				const elapsed = touchFullyBlackTime ? Date.now() - touchFullyBlackTime : 0;
				const remaining = Math.max(0, TOUCH_MIN_BLACK_DURATION - elapsed);

				touchExitTimeout = window.setTimeout(() => {
					touchExitTimeout = null;
					triggerTouchExitAnimation();
				}, remaining);
			}

			function triggerTouchExitAnimation() {
				touchExitAnimationRunning = true;

				// Create array of all cell positions
				const cellPositions: { r: number; c: number }[] = [];
				for (let r = 0; r < rows; r++) {
					for (let c = 0; c < cols; c++) {
						cellPositions.push({ r, c });
					}
				}

				// Shuffle using Fisher-Yates
				for (let i = cellPositions.length - 1; i > 0; i--) {
					const j = Math.floor(Math.random() * (i + 1));
					[cellPositions[i], cellPositions[j]] = [cellPositions[j], cellPositions[i]];
				}

				// Stagger each cell turning white
				const totalDuration = 400;
				const delayPerCell = totalDuration / cellPositions.length;

				cellPositions.forEach((pos, index) => {
					setTimeout(() => {
						targetCells[pos.r][pos.c] = 0;
						startAnimation();
						// Mark exit animation complete after last cell
						if (index === cellPositions.length - 1) {
							touchExitAnimationRunning = false;
						}
					}, index * delayPerCell);
				});

				touchFullyBlackTime = null;
			}

			function triggerTouchRipple(touchX: number, touchY: number) {
				const rect = button.getBoundingClientRect();
				const x = touchX - rect.left;
				const y = touchY - rect.top;
				const startCol = Math.floor(x / CELL_SIZE);
				const startRow = Math.floor(y / CELL_SIZE);

				const maxDist = Math.sqrt(cols * cols + rows * rows);

				for (let r = 0; r < rows; r++) {
					for (let c = 0; c < cols; c++) {
						const dist = Math.sqrt((c - startCol) ** 2 + (r - startRow) ** 2);
						const delay = (dist / maxDist) * 350;

						setTimeout(() => {
							if (touchEnterAnimationRunning) {
								targetCells[r][c] = 1;
								startAnimation();
							}
						}, delay);
					}
				}
			}

			button.addEventListener("touchstart", (e) => {
				isTouchDevice = true;
				const touch = e.touches[0];

				// If exit animation is running, ignore tap
				if (touchExitAnimationRunning) {
					return;
				}

				// If exit animation is scheduled, cancel it and debounce
				if (touchExitTimeout !== null) {
					clearTimeout(touchExitTimeout);
					touchExitTimeout = null;
					// Reset the fully black time to now to restart the timer
					touchFullyBlackTime = Date.now();
					scheduleTouchExit();
					return;
				}

				// If enter animation is still running, don't interrupt
				if (touchEnterAnimationRunning) {
					return;
				}

				// Start fresh enter animation
				touchEnterAnimationRunning = true;
				touchFullyBlackTime = null;
				triggerTouchRipple(touch.clientX, touch.clientY);
			}, { passive: true });

			// Keyboard animation functions
			function updateKeyboardRipple() {
				const centerCol = (cols - 1) / 2;
				const centerRow = (rows - 1) / 2;
				keyboardMaxDist = Math.sqrt(centerCol * centerCol + centerRow * centerRow);
				
				// Current ripple radius based on progress
				const currentRadius = keyboardRippleProgress * keyboardMaxDist;

				for (let r = 0; r < rows; r++) {
					for (let c = 0; c < cols; c++) {
						const dist = Math.sqrt((c - centerCol) ** 2 + (r - centerRow) ** 2);
						// Cell is black if within current ripple radius
						targetCells[r][c] = dist <= currentRadius ? 1 : 0;
					}
				}
				startAnimation();
			}

			function animateKeyboardRipple() {
				const speed = 0.04; // Same speed for enter and exit
				let targetProgress = keyboardPressed ? 1 : 0;

				if (Math.abs(keyboardRippleProgress - targetProgress) > 0.01) {
					if (keyboardPressed) {
						keyboardRippleProgress += speed;
						if (keyboardRippleProgress > 1) keyboardRippleProgress = 1;
					} else {
						keyboardRippleProgress -= speed;
						if (keyboardRippleProgress < 0) keyboardRippleProgress = 0;
					}
					updateKeyboardRipple();
					keyboardAnimationFrame = requestAnimationFrame(animateKeyboardRipple);
				} else {
					keyboardRippleProgress = targetProgress;
					updateKeyboardRipple();
					keyboardAnimationFrame = null;
				}
			}

			function startKeyboardAnimation() {
				if (!keyboardAnimationFrame) {
					keyboardAnimationFrame = requestAnimationFrame(animateKeyboardRipple);
				}
			}

			button.addEventListener("keydown", (e) => {
				if (e.key !== "Enter" && e.key !== " ") return;
				if (e.repeat) return; // Ignore key repeat
				
				e.preventDefault();
				keyboardPressed = true;
				startKeyboardAnimation();
			});

			button.addEventListener("keyup", (e) => {
				if (e.key !== "Enter" && e.key !== " ") return;
				
				keyboardPressed = false;
				startKeyboardAnimation();
			});

			// Handle blur - treat as key release
			button.addEventListener("blur", () => {
				if (keyboardPressed) {
					keyboardPressed = false;
					startKeyboardAnimation();
				}
			});

			// Prevent mouse events from firing on touch devices
			button.addEventListener("mouseenter", (e) => {
				if (isTouchDevice) return;
				rippleGeneration++;
				isHovered = true;
				triggerRipple(e.clientX, e.clientY);
			});

			button.addEventListener("mousemove", (e) => {
				if (isTouchDevice) return;
				if (isHovered) {
					triggerRipple(e.clientX, e.clientY);
				}
			});

			button.addEventListener("mouseleave", () => {
				if (isTouchDevice) return;
				rippleGeneration++;
				isHovered = false;
				resetCells();
			});

			// Initialize
			resizeCanvas();
			window.addEventListener("resize", resizeCanvas);
		</script>
	</body>
</html>
